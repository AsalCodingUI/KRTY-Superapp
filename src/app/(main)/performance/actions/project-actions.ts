"use server"

import type { Database } from "@/shared/types/database.types"
import { createClient } from "@/shared/api/supabase/server"
import { revalidatePath } from "next/cache"

export async function getProjects(
  quarterFilter?: string,
  statusFilter?: string,
) {
  const supabase = await createClient()

  let query = supabase
    .from("projects")
    .select(
      `
            *,
            project_assignments (
                id,
                role_in_project,
                is_lead,
                profiles (
                    id,
                    full_name,
                    avatar_url
                )
            )
        `,
    )
    .order("created_at", { ascending: false })

  // Apply quarter filter
  if (quarterFilter) {
    if (quarterFilter.endsWith("-All")) {
      // Filter by year only (e.g., "2027-All" â†’ filter where quarter_id starts with "2027-")
      const year = quarterFilter.split("-")[0]
      query = query.like("quarter_id", `${year}-%`)
    } else {
      // Exact match for specific quarter (e.g., "2027-Q1")
      query = query.eq("quarter_id", quarterFilter)
    }
  }

  // Apply status filter
  if (statusFilter) {
    query = query.eq("status", statusFilter)
  }

  const { data, error } = await query

  if (error) {
    console.error("Error fetching projects:", error)
    return { success: false, error: error.message, data: [] }
  }

  return { success: true, data: data || [] }
}

export async function createProject(formData: FormData) {
  const supabase = await createClient()

  const projectData = {
    name: formData.get("name") as string,
    description: formData.get("description") as string,
    start_date: formData.get("start_date") as string,
    end_date: formData.get("end_date") as string,
    // quarter_id is auto-generated by database
  }

  const { data, error } = await supabase
    .from("projects")
    .insert(projectData)
    .select()
    .single()

  if (error) {
    console.error("Error creating project:", error)
    return { success: false, error: error.message }
  }

  revalidatePath("/performance")
  return { success: true, data }
}

export async function updateProject(id: string, formData: FormData) {
  const supabase = await createClient()

  const projectData = {
    name: formData.get("name") as string,
    description: formData.get("description") as string,
    start_date: formData.get("start_date") as string,
    end_date: formData.get("end_date") as string,
    status: formData.get(
      "status",
    ) as Database["public"]["Enums"]["project_status_enum"],
  }

  const { data, error } = await supabase
    .from("projects")
    .update(projectData)
    .eq("id", id)
    .select()
    .single()

  if (error) {
    console.error("Error updating project:", error)
    return { success: false, error: error.message }
  }

  revalidatePath("/performance")
  return { success: true, data }
}

export async function deleteProject(id: string) {
  const supabase = await createClient()

  // Soft delete by setting status to Archived
  const { error } = await supabase
    .from("projects")
    .update({ status: "Archived" })
    .eq("id", id)

  if (error) {
    console.error("Error deleting project:", error)
    return { success: false, error: error.message }
  }

  revalidatePath("/performance")
  return { success: true }
}

export async function permanentDeleteProject(id: string) {
  const supabase = await createClient()

  // Permanently delete from database
  const { error } = await supabase.from("projects").delete().eq("id", id)

  if (error) {
    console.error("Error permanently deleting project:", error)
    return { success: false, error: error.message }
  }

  revalidatePath("/performance")
  return { success: true }
}

export async function getAllUsers() {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from("profiles")
    .select("id, full_name, email, avatar_url, job_title, role")
    .order("full_name", { ascending: true })

  if (error) {
    console.error("Error fetching users:", error)
    return { success: false, error: error.message, data: [] }
  }

  return { success: true, data: data || [] }
}

export async function assignUserToProject(
  projectId: string,
  userId: string,
  role: Database["public"]["Enums"]["project_role_enum"],
  weight?: number,
  isLead?: boolean,
) {
  const supabase = await createClient()

  const assignmentData = {
    project_id: projectId,
    user_id: userId,
    role_in_project: role,
    weight_in_quarter: weight || null,
    is_lead: isLead ?? null,
  }

  const { data, error } = await supabase
    .from("project_assignments")
    .insert(assignmentData)
    .select()
    .single()

  if (error) {
    console.error("Error assigning user:", error)
    return { success: false, error: error.message }
  }

  revalidatePath("/performance")
  return { success: true, data }
}

export async function updateProjectAssignmentLead(
  projectId: string,
  assignmentId: string,
  isLead: boolean,
) {
  const supabase = await createClient()

  if (isLead) {
    const { error: resetError } = await supabase
      .from("project_assignments")
      .update({ is_lead: false })
      .eq("project_id", projectId)

    if (resetError) {
      console.error("Error resetting leads:", resetError)
      return { success: false, error: resetError.message }
    }
  }

  const { error } = await supabase
    .from("project_assignments")
    .update({ is_lead: isLead })
    .eq("id", assignmentId)

  if (error) {
    console.error("Error updating lead:", error)
    return { success: false, error: error.message }
  }

  revalidatePath("/performance")
  return { success: true }
}

export async function removeUserFromProject(assignmentId: string) {
  const supabase = await createClient()

  const { error } = await supabase
    .from("project_assignments")
    .delete()
    .eq("id", assignmentId)

  if (error) {
    console.error("Error removing assignment:", error)
    return { success: false, error: error.message }
  }

  revalidatePath("/performance")
  return { success: true }
}

export async function getProjectAssignments(projectId: string) {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from("project_assignments")
    .select(
      `
            id,
            role_in_project,
            weight_in_quarter,
            is_lead,
            profiles (
                id,
                full_name,
                avatar_url,
                job_title
            )
        `,
    )
    .eq("project_id", projectId)

  if (error) {
    console.error("Error fetching assignments:", error)
    return { success: false, error: error.message, data: [] }
  }

  return { success: true, data: data || [] }
}
